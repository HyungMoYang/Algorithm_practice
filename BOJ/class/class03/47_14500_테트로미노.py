import sys
input = sys.stdin.readline

shape = [
    [(0, 0), (0, 1), (1, 0), (1, 1)],  # ㅁ

    [(0, 0), (0, 1), (0, 2), (0, 3)],  # ㅡ
    [(0, 0), (1, 0), (2, 0), (3, 0)],  # ㅣ

    [(0, 0), (1, 0), (1, 1), (1, 2)],  # ㄴ
    [(1, 0), (1, 1), (1, 2), (0, 2)],
    [(0, 0), (1, 0), (2, 0), (2, 1)],
    [(0, 1), (1, 1), (2, 1), (2, 0)],

    [(0, 0), (0, 1), (0, 2), (1, 2)],  # ㄱ
    [(0, 0), (1, 0), (0, 1), (0, 2)],
    [(0, 0), (0, 1), (1, 1), (2, 1)],
    [(0, 0), (0, 1), (1, 0), (2, 0)],

    [(0, 0), (1, 0), (1, 1), (2, 1)],  # ㄴㄱ
    [(0, 1), (1, 1), (1, 0), (2, 0)],  # 역ㄱ역ㄴ
    [(1, 0), (1, 1), (0, 1), (0, 2)],  # 역ㄴ역ㄱ
    [(0, 0), (0, 1), (1, 1), (1, 2)],  # ㄱㄴ

    [(0, 1), (1, 0), (1, 1), (1, 2)],  # ㅗ
    [(0, 0), (0, 1), (0, 2), (1, 1)],  # ㅜ
    [(1, 0), (1, 1), (0, 1), (2, 1)],  # ㅓ
    [(0, 0), (1, 0), (2, 0), (1, 1)],  # ㅏ
]


def find_value(x, y):
    global rst

    for directions in shape:
        sum_value = 0

        # 네 점 확인
        for i in range(4):
            nx = x + directions[i][0]  # next x position
            ny = y + directions[i][1]  # next y position

            # 한 점이라도 graph 범위를 넘어서면 성립하지 않는다.
            if nx <= -1 or nx >= n or ny <= -1 or ny >= m:
                sum_value = 0
                break

            sum_value += graph[nx][ny]

        rst = max(rst, sum_value)


n, m = map(int, input().split())  # row, col
graph = [list(map(int, input().split())) for _ in range(n)]  # input graph

rst = -1  # 결과 값
for i in range(n):
    for j in range(m):
        find_value(i, j)

print(rst)


"""
47. 14500 테트로미노 (Gold 5)
    - 완전탐색 문제로 처음에는 기준 좌표(x, y)에서 왼쪽/위쪽으로 가는 경우에는 이미 탐색한 좌표라고 생각했으나,
      실제로는 ㄴ이나 ㄱ모양에서 위처럼 생각하면 탐색하지 않는 구간이 생긴다. 
      때문에, 만들어질 수 있는 모든 모양의 좌표를 생각해서 미리 shape으로 정의해둔 뒤 각각 좌표를 탐색한다. 
    
    - 첫 번째 시도에서 python3으로는 TLE가 나서 pypy3로 통과하였다. 

    - 위 코드에서 이중 for문에 함수를 호출하는 구간(59줄)에서 함수로 나누지 않고 shape의 directions을 탐색했는데, 
      이 부분을 find_value()로 함수화 했더니, TLE가 나지 않고 잘 통과했고, 
      이후 time으로 시간을 재보니 굉장히 유의미한 차이가 있었다. 
    
    - 별다른 장치 없이 함수 내부에서 똑같이 이중 for문을 돌리는 코드인데, 함수화 하고 안하고의 차이가 
      굉장히 많이 나는게 신기했다. 이전에는 같다고 생각해서 최대한 루프를 돌리지 않으려고 했는데, 아닌듯..
      함수화시키면서 좌표에 대한 계산만 분배 해줘도 시간을 많이 줄일 수 있음을 알았다. 
"""
